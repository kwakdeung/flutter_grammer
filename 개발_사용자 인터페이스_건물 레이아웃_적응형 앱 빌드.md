# Adaptive(적응형) 앱 빌드  

## 개요  

단일 코드베이스에서 모바일, 데스크톱 및 웹에서 실행할 수 있는 앱을 빌드할 수 있는 새로운 기회를 제공합니다.  
멀티플랫폼일 뿐만 아니라 완전히 플랫폼 적응형인 앱을 빌드해야 합니다.

플랫폼 적응형 앱 개발에 대한 3가지 주요 범주
* 레이아웃
* input(입력)
* 관용구와 규범  

[![Building platform adaptive apps | Session](http://img.youtube.com/vi/RCdeSKVt7LI/0.jpg)](https://youtu.be/RCdeSKVt7LI)  

<br/>

## 적응형 레이아웃 구축  

적응형 레이아웃 구축의 고려사항
* 앱이 실행될 화면의 **다양한 크기와 모양**에 앱을 **적용**하는 방법  

<br/>

### 레이아웃 위젯

앱이나 웹 사이트를 구축해 왔다면 반응형 인터페이스를 만드는 데 익숙할 것입니다.  
**Flutter 개발자**에게는 운 좋게도 이를 **더 쉽게** 만들어 주는 많은 위젯 세트가 있습니다.  

Flutter의 가장 유용한 레이아웃 위젯  

**Single child**  
* Align: 하위 자체를 Aligns(정렬). vertical(수직) 및 horizontal(수평) 정렬 모두에 대해 -1과 1 사이의 double 값을 사용.
* AspectRatio: 특정 종횡비로 하위 크기를 조정하려고 시도.
* ConstrainedBox: 하위에 크기 제약을 부과하여 최소 또는 최대 크기를 제어할 수 있습니다.
* CustomSingleChildLayout: 대리자 함수를 사용하여 단일 자식을 배치합니다. 대리자는 자식의 레이아웃 제약 조건과 위치를 결정할 수 있습니다.
* Expanded와 Flexible: 사용 가능한 공간을 채우기 위해 Row 또는 Column의 하위 항목을 축소하거나 확장할 수 있습니다.
* FractionallySizedBox: 하위 크기를 사용 가능한 공간의 일부로 조정
* LayoutBuilder: 상위 크기에 따라 자체적으로 리플로우할 수 있는 위젯을 빌드합니다.
* SingleChildScrollView: 단일 하위 항목에 스크롤을 추가. Row 또는 Column과 함께 자주 사용됩니다.  
<br/>
**Multichild**
* Column, Row, and Flex: 단일 수평 또는 수직 런으로 하위를 배치. Column 및 Row 둘 다 위젯 Flex를 확장합니다.
* CustomMultiChildLayout: 대리자 기능을 사용하여 레이아웃 단계에서 여러 자식을 배치
* Flow: CustomMultiChildLayout와 유사, 레이아웃 단계가 아닌 페인트 단계에서 수행되기 때문에 더 효율적
* ListView, GridView, and CustomScrollView: 스크롤 가능한 하위 목록을 제공
* Stack: Stack의 모서리를 기준으로 여러 자 피쳐를 레이어링하고 배치, CSS에서 위치 고정과 유사한 기능
* Table: 여러 Row과 Column을 결합하여 자식에 대한 클래식 테이블 레이아웃 알고리즘을 사용
* Wrap: 하위를 여러 수평 또는 수직 런으로 표시  

렌더링? 화면에 표시할 웹 페이지/앱 화면을 만드는 과정
페인트 단계? 레이아웃에서 실제 화면에 반영되지 않기에 Render Tree를 다시 화면에 그려주는 과정

플러터의 렌더링의 3단계  
**레이아웃,배치(Layout)-페인트(Paint)-컴포지션,구도(Composition)**  
(출처:  
https://defineall.tistory.com/707,  
https://boxfoxs.tistory.com/408,  
https://velog.io/@broccolism/Flutter-%EC%9D%B4-%EC%BD%94%EB%93%9C..-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%94%BD%EC%85%80%EB%A1%9C-%EC%98%AE%EA%B2%A8%EC%A7%88%EA%B9%8C-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9B%90%EB%A6%AC-3.-%ED%8E%98%EC%9D%B8%ED%8C%85)

사용 가능한 위젯과 예제 코드를 더 보려면 레이아웃 위젯을 참조하십시오.  

<br/>  

## VisualDensity(시각적 밀도)  

VisualDensity 클래스: 전체 애플리케이션에서 **보기 밀도를 쉽게 조정**할 수 있습니다.  

>특징
>* MaterialApp, MaterialComponents 위한 VisualDensity를 변경하면 밀도가 일치하도록 애니메이션을 지원
>* 기본적으로 horizontal(수평) 및 vertical(수직) 밀도는 모두 0.0으로 설정 -> 밀도를 원하는 음수 또는 양수 값으로 설정 가능
>* 다른 밀도 간에 전환하여 UI를 쉽게 조정  

![](https://docs.flutter.dev/assets/images/docs/development/ui/layout/adaptive_scaffold.gif)  

사용자 지정 시각적 밀도를 설정하려면 밀도를 MaterialApp 테마에 주입합니다.  
```dart
double densityAmt = touchMode ? 0.0 : -1.0;
VisualDensity density =
    VisualDensity(horizontal: densityAmt, vertical: densityAmt);
return MaterialApp(
  theme: ThemeData(visualDensity: density),
  home: MainAppScaffold(),
  debugShowCheckedModeBanner: false,
);
```  

자신의 뷰 내부 VisualDensity에서 사용하려면 조회할 수 있습니다.

```dart
VisualDensity density = Theme.of(context).visualDensity;
```  
container(컨테이너)는 밀도 변화에 **자동으로 반응**할 뿐만 아니라 **변화할 때도 애니메이션을 적용**합니다. 이렇게 하면 내장 구성 요소와 함께 사용자 지정 구성 요소를 연결하여 앱 전체에서 부드러운 전환 효과를 얻을 수 있습니다.

VisualDensity 표시된대로 단위가 없으므로 보기에 따라 다른 의미를 가질 수 있습니다. 이 예에서 1 밀도 단위는 6픽셀과 동일하지만 결정은 전적으로 귀하의 보기에 달려 있습니다. 단위가 없다는 사실은 매우 다재다능하며 대부분의 상황에서 작동해야 합니다.

Material Components는 일반적으로 각 시각적 밀도 단위에 대해 약 4개의 논리적 픽셀 값을 사용한다는 점에 주목할 가치가 있습니다. 지원되는 구성 요소에 대한 자세한 내용은 VisualDensityAPI를 참조하십시오. 일반적인 밀도 원칙에 대한 자세한 내용은 Material 디자인 가이드를 참조하십시오.

<br/>

## Contextual layout(상황별 레이아웃)  

밀도 변경 이상의 것이 필요하고 필요한 위젯을 찾을 수 없는 경우 - 매개변수를 조정하고, 크기를 계산하고, 위젯을 교환하거나, 특정 폼 팩터에 맞게 UI를 완전히 재구성하는 것보다 **절차적인 접근 방식**을 취할 수 있습니다.

### 화면 기반 중단점: 가장 단순한 형태의 절차적 레이아웃  

MediaQueryAPI를 사용하여 이 작업을 수행  
MediaQuery 위젯을 사용하는 대표적 이유: 현재 기기의 화면 크기를 구할 시 찾기 위해
(출처: https://mike123789-dev.tistory.com/entry/%ED%94%8C%EB%9F%AC%ED%84%B020-MediaQuery-%EA%B8%B0%EA%B8%B0-%EC%A0%95%EB%B3%B4-%EA%B5%AC%ED%95%98%EA%B8%B0)
```dart
class FormFactor {
  static double desktop = 900;
  static double tablet = 600;
  static double handset = 300;
}
```  
중단점을 사용하여 간단한 시스템을 설정하여 장치 유형을 결정  
```dart
ScreenType getFormFactor(BuildContext context) {
  // Use .shortestSide to detect device type regardless of orientation
  double deviceWidth = MediaQuery.of(context).size.shortestSide; //MediaQuery.of(context).size: 화면 크기
  if (deviceWidth > FormFactor.desktop) return ScreenType.Desktop;
  if (deviceWidth > FormFactor.tablet) return ScreenType.Tablet;
  if (deviceWidth > FormFactor.handset) return ScreenType.Handset;
  return ScreenType.Watch;
}
```  
대안으로 더 추상화하고 크고 작은 관점에서 정의할 수 있습니다.
```dart
enum ScreenSize { Small, Normal, Large, ExtraLarge }

ScreenSize getSize(BuildContext context) {
  double deviceWidth = MediaQuery.of(context).size.shortestSide; 
  // shortestSide: 600p 미만
  // (출처: https://pub.dev/documentation/hy_flutter/latest/hy_flutter/ContextExt.html)
  if (deviceWidth > 900) return ScreenSize.ExtraLarge;
  if (deviceWidth > 600) return ScreenSize.Large;
  if (deviceWidth > 300) return ScreenSize.Normal;
  return ScreenSize.Small;
}
```  
화면 기반 중단점은 앱에서 최상위 수준의 결정을 내리는 데 가장 잘 사용됩니다.  
visual density(시각적 밀도), paddings, or font-sizes와 같은 변경 사항은 전역 기반으로 정의할 때 가장 좋습니다.  
최상위 위젯 트리를 reflow 할 수도 있습니다.  
예) handset 미사용 시 세로 레이아웃에서 가로 레이아웃으로 전환

```dart
bool isHandset = MediaQuery.of(context).size.width < 600;
return Flex(
    children: [Text('Foo'), Text('Bar'), Text('Baz')],
    direction: isHandset ? Axis.vertical : Axis.horizontal);
```  
다른 위젯에서는 일부 하위 항목을 완전히 바꿀 수 있습니다.
```dart
Widget foo = Row(
  children: [
    ...isHandset ? _getHandsetChildren() : _getNormalChildren(),
  ],
);
```  

<br/>

## Use LayoutBuilder for extra flexibility(추가 유연성을 위해 LayoutBuilder 사용)  

LayoutBuilder 클래스: **Widget의 크기를 확인하고 지정**  
(출처: https://velog.io/@quddkflty/Dart-LayoutBuilder)  

필요할 때  
* 전체 화면 크기를 확인하는 것이 전체 화면 페이지나 전역 레이아웃 결정에 적합하지만 중첩된 하위 보기에는 적합하지 않은 경우(종종 하위 뷰에는 **자체 내부 중단점**이 있으며 **렌더링에 사용할 수 있는 공간에만** 관심)  

```dart
Widget foo = LayoutBuilder(
    builder: (context, constraints) {
  bool useVerticalLayout = constraints.maxWidth < 400.0;
  return Flex(
    children: [
      Text('Hello'),
      Text('World'),
    ],
    direction: useVerticalLayout ? Axis.vertical : Axis.horizontal,
  );
});
```  
* 측면 (panel)패널, dialog(대화 상자) 또는 전체 화면 보기 내에서 구성  
* 제공되는 공간에 따라 레이아웃을 조정  

<br/>

## Device segmentation(기기 세분화)  
**크기에 관계없이** 실행 중인 실제 플랫폼을 기반으로 **레이아웃 결정**을 내리고 싶을 때 

사용 중인 플랫폼 조합을 확인하려면 다음 값 kIsWeb과 함께 Platform API를 사용할 수 있습니다.  

```dart
bool get isMobileDevice => !kIsWeb && (Platform.isIOS || Platform.isAndroid);
bool get isDesktopDevice =>
    !kIsWeb && (Platform.isMacOS || Platform.isWindows || Platform.isLinux);
bool get isMobileDeviceOrWeb => kIsWeb || isMobileDevice;
bool get isDesktopDeviceOrWeb => kIsWeb || isDesktopDevice;
```  

dart.io 패키지가 웹 대상에서 지원되지 않기 때문에 예외를 throw하지 않고 웹 빌드에서 Platform API에 액세스할 수 없습니다. 결과적으로 이 코드는 웹을 먼저 확인하고 단락으로 인해 Dart는 Platform 웹 대상을 호출하지 않습니다.  

<br/>

## Single source of truth for styling(스타일링을 위한 단일 소스)  

padding, spacing(간격), corner shape(모서리 모양), font sizes 등과 같은 값을 **스타일링하기 위한 단일 소스를 생성**하면 보기를 **유지 관리하기가 더 쉬울 것**입니다. 이것은 일부 도우미 클래스를 사용하여 쉽게 수행할 수 있습니다.  
```dart
class Insets {
  static const double xsmall = 3;
  static const double small = 4;
  static const double medium = 5;
  static const double large = 10;
  static const double extraLarge = 20;
  // etc
}

class Fonts {
  static const String raleway = 'Raleway';
  // etc
}

class TextStyles {
  static const TextStyle raleway = const TextStyle(
    fontFamily: Fonts.raleway, 
    // fontFamily: 글꼴을 정하는 속성
    // raleway - 폰트 종류 중 하나
  );
  static TextStyle buttonText1 =
      TextStyle(fontWeight: FontWeight.bold, fontSize: 14);
  static TextStyle buttonText2 =
      TextStyle(fontWeight: FontWeight.normal, fontSize: 11);
  static TextStyle h1 = TextStyle(fontWeight: FontWeight.bold, fontSize: 22);
  static TextStyle h2 = TextStyle(fontWeight: FontWeight.bold, fontSize: 16);
  static late TextStyle body1 = raleway.copyWith(color: Color(0xFF42A5F5)); 
  // late 연산자: 변수의 초기화를 지연시켜줌, null 허용X, 해당 변수가 사용되기 전에만 변수를 초기화 하면 됨 (출처: https://medium.com/flutter-korea/flutter%EC%9D%98-null-safety-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-dd4ee1f7d6a5)
  // .copyWith: 플러터 위젯 속성값 변경, 여기서는 raleway 속성 값(글꼴 색상 0xFF42A5F5)으로 변경 적용(출처: https://dev-nam.tistory.com/13)
  // etc
}
```  
그런 다음 하드 코딩된 숫자 값 대신 다음 상수를 사용할 수 있습니다.
```dart
return Padding(
  padding: EdgeInsets.all(Insets.small),
  child: Text('Hello!', style: TextStyles.body1),
);
```  

일반적인 디자인 시스템 범주
* Animation 타이밍
* Sizes and breakpoints(크기 및 중단점)
* Insets and paddings
* Corner radius(코너 반경)
* 그림자
* Strokes
* Font families, sizes, and styles  
<br/>

(일반적인 디자인 시스템 범주) 예외사항  
* (앱의 다른 곳에서는 사용되지 않는)일회성 값
* 동일한 의미 값의 재사용 또는 중복(도 관찰) -> 전역 스타일 지정 규칙 집합에 추가  

<br/>

## Design to the strengths of each form factor(각 폼 요소의 장점을 고려한 설계)  

화면 크기 외에도 **다양한 폼 요소의 고유한 강점과 약점을 고려**하는 데 시간을 투자해야 합니다. 멀티플랫폼 앱이 모든 곳에서 동일한 기능을 제공하는 것이 항상 이상적인 것은 아닙니다. 일부 장치 범주에서 **특정 기능에 중점**을 두거나 **특정 기능을 제거**하는 것이 합리적인지 고려하십시오.  

중요한 점: 각 플랫폼이 **가장 잘하는 것**이 무엇인지 생각하고 **활용할 수 있는 고유한 기능**이 있는지 확인하는 것  

> **예:**  
>1. 모바일 장치는 휴대가 가능하고 카메라가 있지만 세부적인 창작 작업에는 적합하지 않습니다.  
>2. 웹의 극히 낮은 공유 장벽을 활용하는 것.